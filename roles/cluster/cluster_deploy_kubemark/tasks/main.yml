- name: Define versions and properties
  set_fact:
    clusterctl_version: v1.5.1
    capi_kubemark_version: v0.6.0
    capi_operator_version: main
    kubemark_worker_machine_count: 4
    capi_namespace: openshift-cluster-api

- name: Get the name of the cluster
  command:
    oc get infrastructure cluster -o jsonpath="{.status.infrastructureName}"
  register: cluster_name_cmd

- name: Get the K9s version of the cluster
  shell:
    set -o pipefail;
    oc version -ojson | jq -r .serverVersion.gitVersion | cut -d+ -f1 | cut -b2-
  register: k8s_version_cmd

- name: Save the cluster name
  set_fact:
    cluster_name: "{{ cluster_name_cmd.stdout }}"
    k8s_version: "{{ k8s_version_cmd.stdout }}"

- name: Enable Tech
  shell: |
    set -o pipefail;
    cat <<EOF | kubectl apply -f -
    apiVersion: config.openshift.io/v1
    kind: FeatureGate
    metadata:
      name: cluster
    spec:
      featureSet: TechPreviewNoUpgrade
    EOF

- name: Install clusterctl
  shell: |
    curl -sSf --silent -L https://github.com/kubernetes-sigs/cluster-api/releases/download/{{ clusterctl_version }}/clusterctl-linux-amd64 -o /tmp/clusterctl
    chmod +x /tmp/clusterctl

- name: Prepare the config file
  shell: |
    cat <<EOF > {{ artifact_extra_logs_dir }}/clusterctl.yaml
    providers:
    - name: "kubemark"
      url: "https://github.com/kubernetes-sigs/cluster-api-provider-kubemark/releases/{{ capi_kubemark_version }}/infrastructure-components.yaml"
      type: "InfrastructureProvider"
    EOF

- name: Check if the capi-system namespace exits
  shell:
    oc get ns capi-system -oname 2>/dev/null
  register: has_capi_system_namespace_cmd
  failed_when: false

- name: Initialize kubemark provider
  shell:
    /tmp/clusterctl init
       --infrastructure kubemark
       --config {{ artifact_extra_logs_dir }}/clusterctl.yaml
  when: has_capi_system_namespace_cmd.rc != 0

# Beginning of the work arounds

# Workaround 1

- name: Wait for the capi-system namespace to appear
  shell:
    oc get ns capi-system -oname 2>/dev/null
  register: has_namespace_cmd
  until: has_namespace_cmd.rc == 0
  retries: 20
  delay: 10

- name: Apply the workaround 1
  shell: |
    oc adm policy add-scc-to-user privileged -z capi-manager -n capi-system
    oc delete replicaset --all  -n capi-system --ignore-not-found

# Workaround 2
- name: Wait for the capi-kubeadm-bootstrap-system namespace to appear
  shell:
    oc get ns capi-kubeadm-bootstrap-system -oname 2>/dev/null
  register: has_namespace_cmd
  until: has_namespace_cmd.rc == 0
  retries: 20
  delay: 10

- name: Apply the workaround 2
  shell: |
    oc adm policy add-scc-to-user privileged -z capi-kubeadm-bootstrap-manager -n capi-kubeadm-bootstrap-system
    oc delete replicaset --all -n capi-kubeadm-bootstrap-system

# Workaround 3
- name: Apply the workaround 3
  shell: |
    oc adm policy add-scc-to-user privileged -z capi-kubeadm-control-plane-manager -n capi-kubeadm-control-plane-system
    oc delete replicaset --all  -n capi-kubeadm-control-plane-system

# End of the work around

- name: Wait for the deployment to be ready
  command:
    oc get deploy/capi-controller-manager -n capi-system -ojsonpath={.status.readyReplicas}
  register: deployments_ready
  retries: 20
  delay: 10
  until: deployments_ready.stdout | length > 0

- name: Wait for the deployment to be ready
  command:
    oc get deploy/capi-kubeadm-bootstrap-controller-manager -n capi-kubeadm-bootstrap-system -ojsonpath={.status.readyReplicas}
  register: deployments_ready
  retries: 20
  delay: 10
  until: deployments_ready.stdout | length > 0

# ---

- name: Get the CAPI AWS cluster template
  shell:
    curl -Ssf https://raw.githubusercontent.com/openshift/cluster-capi-operator/{{ capi_operator_version }}/hack/clusters/templates/aws.yaml > "{{ artifact_extra_logs_dir }}/capi_aws_template.yaml"

- name: Get the CAPI AWS cluster template
  shell:
    curl -Ssf https://raw.githubusercontent.com/openshift/cluster-capi-operator/{{ capi_operator_version }}/hack/clusters/templates/core.yaml > "{{ artifact_extra_logs_dir }}/capi_core_template.yaml"

- name: Wait for the capi namespace to appear
  shell:
    oc get ns "{{ capi_namespace }}" -oname 2>/dev/null
  register: has_namespace_cmd
  until: has_namespace_cmd.rc == 0
  retries: 20
  delay: 10

- name: Wait for the AWSCluster CRD to appear
  shell:
    oc get crd awsclusters.infrastructure.cluster.x-k8s.io -oname 2>/dev/null
  register: has_crd_cmd
  until: has_crd_cmd.rc == 0
  retries: 30
  delay: 10

- name: Create the AWSCluster and Cluster resources
  shell: |
    set -o pipefail;
    set -e

    # based on https://github.com/openshift/cluster-capi-operator/blob/main/hack/clusters/create-aws.sh

    export CLUSTER_NAME="{{ cluster_name }}"
    export AWS_REGION=$(oc get machineset.machine.openshift.io -n openshift-machine-api -o jsonpath="{.items[0].spec.template.spec.providerSpec.value.placement.region}")
    export INFRASTRUCTURE_KIND=AWSCluster

    cat "{{ artifact_extra_logs_dir }}/capi_aws_template.yaml" | envsubst | oc apply -f- -n "{{ capi_namespace }}"
    cat "{{ artifact_extra_logs_dir }}/capi_core_template.yaml" | envsubst | oc apply -f- -n "{{ capi_namespace }}"

# ---

- name: Generate the kubemark cluster resources
  shell:
    set -o pipefail;

    /tmp/clusterctl generate cluster "{{ cluster_name }}"
        --infrastructure kubemark
        --kubernetes-version {{ k8s_version }}
        --worker-machine-count={{kubemark_worker_machine_count}}
        --config {{ artifact_extra_logs_dir }}/clusterctl.yaml
      | yq '.metadata.namespace = "{{ capi_namespace }}"'
        > "{{ artifact_extra_logs_dir }}/kubemark_cluster.yaml"

- name: Apply the kubemark template
  command:
    oc apply -f "{{ artifact_extra_logs_dir }}/kubemark_cluster.yaml"
