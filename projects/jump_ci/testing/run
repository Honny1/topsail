#!/usr/bin/env python

import sys, os
import pathlib
import subprocess
import fire
import logging
logging.getLogger().setLevel(logging.INFO)
import datetime
import time
import functools
import atexit
import yaml
import jsonpath_ng
import tempfile

from projects.core.library import env, config, run, configure_logging
configure_logging()


TESTING_THIS_DIR = pathlib.Path(__file__).absolute().parent

initialized = False
def init(ignore_secret_path=False, apply_preset_from_pr_args=True):
    global initialized
    if initialized:
        logging.debug("Already initialized.")
        return
    initialized = True

    env.init()
    config.init(TESTING_THIS_DIR)


def entrypoint(ignore_secret_path=False, apply_preset_from_pr_args=True):
    def decorator(fct):
        @functools.wraps(fct)
        def wrapper(*args, **kwargs):
            init(ignore_secret_path, apply_preset_from_pr_args)
            fct(*args, **kwargs)

        return wrapper
    return decorator


@entrypoint()
def prepare():
    """
    Prepares the jump-host for running TOPSAIL commands.
    """

    #
    # Clone the Git Repository
    #

    #
    # Build the image
    #

    #
    # Run the test
    #

    #
    # Download the artifacts
    #

    return None


def jump_ci(command):
    @entrypoint()
    def do_jump_ci():
        """
        *Jump-CI* Runs the command in the Jump Host.
    """
        prepare_jump_ci()

    return do_jump_ci


@entrypoint()
def open_tunnel(
        secret_env_key="PSAP_ODS_SECRET_PATH",
        private_key_filename="jumpci_privatekey",
        jump_host_filename="jumpci_jump_host",
        local_host_port=2500,
        bastion_host_filename="jumpci_bastion_host",
        bastion_host_port=22,
        verbose=False,
        keep_open=True,
        ssh_flags=[],
):
    """
    Tests the tunnel to access the jump host.

    Args:
      secret_env_key: name of the env key pointing to the secret directory
      private_key_filename: name of the secret file in the secret directory
      jump_host_filename: ssh name of the jump host
      local_host_port: port to open locally
      bastion_host_filename: name of the secret file with the hostname of the bastion host
      bastion_host_port: port to redirect in the target host
      verbose: if enabled, shows the tunnel command
      keep_open: if disabled, closes the tunnel when the Python process exits
      ssh_flags: extra flags to pass to SSH
    """

    secret_dir = pathlib.Path(os.environ[secret_env_key])

    private_key_path = secret_dir / private_key_filename

    with open(secret_dir / jump_host_filename) as f:
        jump_host = f.readline().strip()

    with open(secret_dir / bastion_host_filename) as f:
        bastion_user, _, bastion_host = f.readline().strip().rpartition("@") # strip any username in the hostname

    # warning: this command doesn't fail ...
    cmd = f"ssh {ssh_flags} \
    -i {private_key_path} {jump_host} \
    -L {local_host_port}:{bastion_host}:{bastion_host_port} \
    -N"

    if verbose:
        logging.info(cmd)

    proc = subprocess.Popen(cmd, shell=True)

    if not keep_open:
        atexit.register(proc.kill)

    RETRIES = 150
    DELAY = 5
    logging.info("Waiting for the SSH connection to work ...")
    time.sleep(DELAY)
    for i in range(RETRIES):
        try:
            probe_ssh_endpoint(bastion_user, "localhost", local_host_port, private_key_path, ssh_flags, verbose)
            logging.info(f"SSH connection working!")
            break
        except subprocess.CalledProcessError:
            logging.info(f"Attempt {i+1}/{RETRIES} failed ...")
            if i == (RETRIES - 1):
                raise Exception("SSH connection probe failed :/")
            time.sleep(DELAY)

    return

def probe_ssh_endpoint(user, host, port, private_key_path, ssh_flags, verbose):
    run.run(f"ssh {ssh_flags} -i {private_key_path} {user + '@' if user else ''}{host} -p {port} true",
            capture_stderr=True,
            log_command=verbose)

@entrypoint()
def prepare_jump_ci(
        verbose=None,
):
    """
    Prepare the jump host to run TOPSAIL

    Args:
      verbose: if enabled, displays additional info. *Will display SSH host names*.
    """

    LOCAL_HOST_PORT = config.project.get_config("ssh_tunnel.local_host_port")
    SECRET_ENV_KEY = config.project.get_config("secrets.dir.env_key")
    PRIVATE_KEY_FILENAME = config.project.get_config("secrets.private_key_filename")
    BASTION_HOST_FILENAME = config.project.get_config("secrets.bastion_host_filename")
    JUMP_HOST_FILENAME = config.project.get_config("secrets.jump_host_filename")
    SSH_FLAGS = " ".join(config.project.get_config("ssh.flags"))

    private_key_path = pathlib.Path(os.environ[SECRET_ENV_KEY]) / PRIVATE_KEY_FILENAME


    if verbose is None:
        verbose = config.project.get_config("ssh_tunnel.verbose")

    with open(pathlib.Path(os.environ[SECRET_ENV_KEY]) / BASTION_HOST_FILENAME) as f:
        bastion_user, _, bastion_host = f.readline().strip().rpartition("@") # strip any username in the hostname

    if config.project.get_config("ssh_tunnel.enabled"):
        logging.info("ssh_tunnel.enabled is set, creating a tunnel to the bastion via the jump host")
        # creates a tunnel to the jumphost to the bastion, on localhost:2500

        open_tunnel(
            secret_env_key=SECRET_ENV_KEY,
            private_key_filename=PRIVATE_KEY_FILENAME,
            bastion_host_filename=BASTION_HOST_FILENAME,
            local_host_port=LOCAL_HOST_PORT,

            jump_host_filename=JUMP_HOST_FILENAME,
            verbose=verbose,
            keep_open=False,
            ssh_flags=SSH_FLAGS,
        )

        remote_host = "localhost"
        remote_host_port = LOCAL_HOST_PORT
    else:
        logging.info("ssh_tunnel.enabled is disabled, connecting directly to the bastion")
        remote_host = bastion_host
        remote_host_port = 22
        probe_ssh_endpoint(bastion_user, bastion_host, remote_host_port, private_key_path, SSH_FLAGS, verbose)

    os.environ["TOPSAIL_JUMP_CI_REMOTE_HOST"] = remote_host

    # generate a fd-only temporary file
    extra_vars_fd, path = tempfile.mkstemp()
    os.remove(path) # using only the FD. Ensures that the file disappears when this process terminates
    extra_vars_f = os.fdopen(extra_vars_fd, 'w')
    os.environ["TOPSAIL_ANSIBLE_PLAYBOOK_EXTRA_VARS"] = f"/proc/{os.getpid()}/fd/{extra_vars_fd}"

    extra_vars_yaml_content = f"""
ansible_port: {remote_host_port}
ansible_ssh_private_key_file: {private_key_path}
ansible_ssh_user: {bastion_user}
ansible_ssh_common_args: "{SSH_FLAGS}"
"""
    print(extra_vars_yaml_content, file=extra_vars_f)
    extra_vars_f.flush()

    run.run_toolbox("nfd", "has_labels")


class JumpCi:
    """
    Commands for launching the Jump CI
    """

    def __init__(self):
        self.pre_cleanup_ci = jump_ci("pre_cleanup_ci")
        self.post_cleanup_ci = jump_ci("post_cleanup_ci")
        self.prepare_ci = jump_ci("prepare_ci")
        self.test_ci = jump_ci("test_ci")
        self.generate_plots_from_pr_args = jump_ci("generate_plots_from_pr_args")

        self.test_tunnel = open_tunnel
        self.prepare_jump_ci = prepare_jump_ci

def main():
    # Print help rather than opening a pager
    fire.core.Display = lambda lines, out: print(*lines, file=out)

    fire.Fire(JumpCi())


if __name__ == "__main__":
    try:
        sys.exit(main())
    except subprocess.CalledProcessError as e:
        logging.error(f"Command '{e.cmd}' failed --> {e.returncode}")
        sys.exit(1)
